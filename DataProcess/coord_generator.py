# -*- coding: utf-8 -*-

"""
This file is to process data generated by OpenGL.
Data generated by OpenGL:
    depth_cam, depth_pro1, depth_pro2 -- from different views;
    Binary files;
    Calibration parameters(In the OpenGL Code)
    No mask info.
Main work:
    1. Read binary file and store them as npy file.
        a) mXXfXX_depth_camXX.npy  str(x).zfill(3)
        b) mask_mat for every type of output
    2. Calculate some calibrated information:
        a) Calculate: M_cp1, D_cp1, M_p1c, D_p1c
    3. Generate flow data.
        a) calculate xy_pro1_cv.npy data
        b) calculate xy_cam_p1v.npy data
        c) save all information.
    4. Usage
        When using the data, load the xy_cam_p1v.npy & xy_pro_cv.npy
            grid_sample: xy_cam_cv.npy data
            (https://pytorch.org/docs/stable/nn.html?highlight=grid_sample#torch.nn.functional.grid_sample)
"""

import csv
import sys
import os
import cv2
from matplotlib import pyplot as plt
import numpy as np


def load_bin_file(file_name, shape):
    """load binary file from disk and convert them into torch tensor/numpy array.

    The binary file is generated from OpenGL program outside. As the OpenGL is row-major, we don't need to do anything
    about the shape, just use reshape directly. However if the mat is generated from matlab, a permute() method is
    needed.
    Also, the OpenGL program is running on the windows platform. The out put variables are float with little endian.
    Output of this method is torch tensor.

    Args:
        :param file_name: '.bin' file name. Will be load directly.
        :param shape: The shape of image. Needed for binary file. Dimention is 2.

    Returns:
        :return: A torch tensor with given shape.

    Raises:
        IOError: Error occurred if cannot load file.
    """
    try:
        item_vec = np.fromfile(file_name, dtype='<f4')
    except IOError as error:
        print("File_name is %s" % file_name)
        raise error

    # item = torch.from_numpy(item_vec.reshape(shape[0], shape[1]))
    item = item_vec.reshape(shape[0], shape[1])
    # item = item.unsqueeze(0)
    # item[torch.isnan(item)] = 0
    return item


def norm_from_depth(depth_mat, mask_mat, pix_per_meter):
    """Calculate norm map from given depth map.

    Use (-dz/dx, -dz/dy, 1). Use (x,y) (x+1, y), (x+1, y+1), (x, y+1).

    Args:
        :param depth_mat: view point from depth_mat
        :param mask_mat: mask mat of depth_mat

    Returns:
        :return: norm_mat, mask_norm

    Raises:
        None.
    """

    # Calculate mask_norm
    mask_xy = mask_mat
    mask_x1y = np.zeros(mask_mat.shape, mask_mat.dtype)
    mask_x1y[1:, :] = mask_xy[:-1, :]
    mask_xy1 = np.zeros(mask_mat.shape, mask_mat.dtype)
    mask_xy1[:, 1:] = mask_xy[:, :-1]
    mask_norm = np.logical_and(mask_xy, mask_x1y)
    mask_norm = np.logical_and(mask_xy1, mask_norm)
    # mask_norm[mask_norm < 3] = 0
    # mask_norm[mask_norm > 0] = 1

    # Calculate depth_derv_x/y
    # Apply gaussian filter to depth map
    depth_xy = cv2.GaussianBlur(depth_mat, (9, 9), 3.0)
    depth_x1y = np.zeros(depth_xy.shape, depth_xy.dtype)
    depth_x1y[1:, :] = depth_xy[:-1, :]
    depth_xy1 = np.zeros(depth_xy.shape, depth_xy.dtype)
    depth_xy1[:, 1:] = depth_xy[:, :-1]
    depth_derv_x = depth_x1y - depth_xy
    depth_derv_y = depth_xy1 - depth_xy

    # Calculate norm_mat
    norm_mat = np.ones([depth_xy.shape[0], depth_xy.shape[1], 3], np.float32)
    norm_mat[:, :, 0] = -depth_derv_x * pix_per_meter
    norm_mat[:, :, 1] = -depth_derv_y * pix_per_meter
    mod_mat = np.sqrt(np.sum(norm_mat*norm_mat, 2))
    norm_mat = norm_mat / mod_mat.reshape(norm_mat.shape[0], norm_mat.shape[1], 1)
    norm_mat[mask_norm == 0] = 0

    return norm_mat, mask_norm


def coord_visualization(xy_mat, range_shape):
    show_mat = np.ones(xy_mat.shape[:2] + tuple([3]))
    show_mat[:, :, 0] = 1.0 - xy_mat[:, :, 0] / range_shape[0]
    show_mat[:, :, 1] = 1.0 - xy_mat[:, :, 1] / range_shape[1]
    return show_mat.astype(np.float32)


def main():

    # Some parameters (You should edit here every time):
    main_path = '/media/qiao/数据文档/SLDataSet/Thing10K/1_3Views/test_3views'
    out_path = '/media/qiao/数据文档/SLDataSet/Thing10K/2_DepthWithCorres'
    folder_name = 'test_corres'
    model_num = 2
    frame_num = 100
    cam_shape = (1024, 1280)
    pro_shape = (800, 1280)
    cam_intrinsic = np.array([[1201.35, 0.0, 640.0], [0.0, 1202.75, 512.0], [0.0, 0.0, 1.0]])
    pro_intrinsic = np.array([[2274.82, 0.0, 640.0], [0.0, 2311.78, 400.0], [0.0, 0.0, 1.0]])
    trans_vec = np.array([46.3635, -22.109, 113.778]).reshape(3, 1) * 1e-3
    rot_mat = np.array([[0.998411, 0.0375734, -0.0419995],
                        [-0.0272844, 0.97441, 0.223118],
                        [0.049308, -0.221618, 0.973886]])
    pro_vec = np.matmul(rot_mat.transpose(), np.array([[0.0], [0.0], [1.0]]))
    pix_per_meter = 1200

    # Step 1: Get dataset file_name list
    depth_cam_names = []
    depth_pro1_names = []
    depth_pro2_names = []
    idx_set = []
    for m_idx in range(1, model_num + 1):
        for f_idx in range(0, frame_num):
            depth_cam_names.append('%s/%d/depth_cam_%d.bin' % (main_path, m_idx, f_idx))
            depth_pro1_names.append('%s/%d/depth_pro1_%d.bin' % (main_path, m_idx, f_idx))
            depth_pro2_names.append('%s/%d/depth_pro2_%d.bin' % (main_path, m_idx, f_idx))
            idx_set.append((m_idx, f_idx))
    total_frame_num = len(depth_cam_names)

    # Step 2: Calculate epipolar information here
    # Calculate Mcp1, Dcp1; Mp1c, Dp1c
    pro_matrix = np.dot(pro_intrinsic, np.hstack((rot_mat, trans_vec)))
    cam_matrix = np.dot(cam_intrinsic, np.hstack((rot_mat.transpose(),
                                                  -np.dot(rot_mat.transpose(), trans_vec))))
    par_mcp1 = np.zeros((cam_shape[0], cam_shape[1], 3))
    par_mp1c = np.zeros((pro_shape[0], pro_shape[1], 3))
    par_dcp1 = pro_matrix[:, 3]
    par_dp1c = cam_matrix[:, 3]
    for h in range(0, cam_shape[0]):
        for w in range(0, cam_shape[1]):
            tmp_vec_cam = np.array([(w - cam_intrinsic[0, 2]) / cam_intrinsic[0, 0],
                                    (h - cam_intrinsic[1, 2]) / cam_intrinsic[1, 1],
                                    1])
            par_mcp1[h, w, :] = np.dot(pro_matrix[:, :3], tmp_vec_cam)
    for h in range(0, pro_shape[0]):
        for w in range(0, pro_shape[1]):
            tmp_vec_pro = np.array([(w - pro_intrinsic[0, 2]) / pro_intrinsic[0, 0],
                                    (h - pro_intrinsic[1, 2]) / pro_intrinsic[1, 1],
                                    1])
            par_mp1c[h, w, :] = np.dot(cam_matrix[:, :3], tmp_vec_pro)
    # print(par_mp1c[378, 597, :])
    # print(par_dp1c)

    # Step 3: Process every frame
    file_path = '%s/%s' % (out_path, folder_name)
    if not os.path.exists(file_path):
        os.mkdir(file_path)
    for idx in range(0, total_frame_num):
        depth_cam = load_bin_file(depth_cam_names[idx], cam_shape)
        depth_pro1 = load_bin_file(depth_pro1_names[idx], pro_shape)
        # depth_pro2 = load_bin_file(depth_pro2_names[idx], image_shape)

        # Set mask
        mask_cam = depth_cam < 9.0
        depth_cam[mask_cam == 0] = 0.0
        mask_pro1 = depth_pro1 < 9.0
        depth_pro1[mask_pro1 == 0] = 0.0
        # mask_pro2 = depth_pro2 < 9.0
        # depth_pro2[mask_pro2 == 0] = 0.0

        if idx_set[idx][0] > 0:
            # Calculate norm mat (-dz/dx, -dz/dy, 1)
            norm_cam, mask_cam = norm_from_depth(depth_cam, mask_cam, pix_per_meter)
            norm_pro1, mask_pro1 = norm_from_depth(depth_pro1, mask_pro1, pix_per_meter)

            # Calculate shape mat
            shade_cam = np.dot(norm_cam, pro_vec)
            mask_cam[shade_cam.reshape(mask_cam.shape) <= 0] = 0
            shade_cam[mask_cam == 0] = 0.0
            shade_pro1 = np.dot(norm_pro1, np.array([[0.0], [0.0], [1.0]]))
            mask_pro1[shade_pro1.reshape(mask_pro1.shape) <= 0] = 0
            shade_pro1[mask_pro1 == 0] = 0.0

        # Calculate xy_pro1_cv
        xy_pro1_cv = np.zeros((cam_shape[0], cam_shape[1], 2))
        tmp_mat_cv = par_mcp1[:, :, 2] * depth_cam + par_dcp1[2]
        xy_pro1_cv[:, :, 0] = par_mcp1[:, :, 0] * depth_cam + par_dcp1[0]
        xy_pro1_cv[:, :, 0] = xy_pro1_cv[:, :, 0] / tmp_mat_cv
        xy_pro1_cv[:, :, 1] = par_mcp1[:, :, 1] * depth_cam + par_dcp1[1]
        xy_pro1_cv[:, :, 1] = xy_pro1_cv[:, :, 1] / tmp_mat_cv
        xy_pro1_cv[mask_cam == 0] = 0.0

        # Calculate xy_cam_p1v
        xy_cam_p1v = np.zeros((pro_shape[0], pro_shape[1], 2))
        tmp_mat_p1v = par_mp1c[:, :, 2] * depth_pro1 + par_dp1c[2]
        xy_cam_p1v[:, :, 0] = par_mp1c[:, :, 0] * depth_pro1 + par_dp1c[0]
        xy_cam_p1v[:, :, 0] = xy_cam_p1v[:, :, 0] / tmp_mat_p1v
        xy_cam_p1v[:, :, 1] = par_mp1c[:, :, 1] * depth_pro1 + par_dp1c[1]
        xy_cam_p1v[:, :, 1] = xy_cam_p1v[:, :, 1] / tmp_mat_p1v
        xy_cam_p1v[mask_pro1 == 0] = 0.0

        # Save
        prefix = 'm%02df%03d' % (idx_set[idx][0], idx_set[idx][1])
        np.save('%s/%s_depth_cam.npy' % (file_path, prefix), depth_cam.astype(np.float32))
        plt.imsave('%s/%s_mask_cam.png' % (file_path, prefix), mask_cam, cmap='Greys_r')
        np.save('%s/%s_depth_pro1.npy' % (file_path, prefix), depth_pro1.astype(np.float32))
        plt.imsave('%s/%s_mask_pro1.png' % (file_path, prefix), mask_pro1, cmap='Greys_r')
        np.save('%s/%s_xy_pro1_cv.npy' % (file_path, prefix), xy_pro1_cv.astype(np.float32))
        plt.imsave('%s/%s_xy_pro1_cv.png' % (file_path, prefix),
                   coord_visualization(xy_pro1_cv, pro_shape), cmap='Greys_r')
        np.save('%s/%s_xy_cam_p1v.npy' % (file_path, prefix), xy_cam_p1v.astype(np.float32))
        plt.imsave('%s/%s_xy_cam_p1v.png' % (file_path, prefix),
                   coord_visualization(xy_cam_p1v, cam_shape), cmap='Greys_r')
        if idx_set[idx][0] > 0:
            plt.imsave('%s/%s_shade_cam.png' % (file_path, prefix), shade_cam.reshape(cam_shape), cmap='Greys_r')
            plt.imsave('%s/%s_shade_pro1.png' % (file_path, prefix), shade_pro1.reshape(pro_shape), cmap='Greys_r')
        # np.save('%s/%s_shade_cam.npy' % (file_path, prefix), shade_cam.astype(np.float32))
        # np.save('%s/%s_shade_pro1.npy' % (file_path, prefix), shade_pro1.astype(np.float32))
        print('%s/%s writing finished.' % (file_path, prefix))

    return


if __name__ == '__main__':
    assert len(sys.argv) >= 1

    main()
