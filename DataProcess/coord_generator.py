# -*- coding: utf-8 -*-

"""
This file is to process data generated by OpenGL.
Data generated by OpenGL:
    depth_cam, depth_pro1, depth_pro2 -- from different views;
    Binary files;
    Calibration parameters(In the OpenGL Code)
    No mask info.
Main work:
    1. Read binary file and store them as npy file.
        a) mXXfXX_depth_camXX.npy  str(x).zfill(3)
        b) mask_mat for every type of output
    2. Calculate some calibrated information:
        a) Calculate: M_cp1, D_cp1, M_p1c, D_p1c
    3. Generate flow data.
        a) calculate xy_pro1_cv.npy data
        b) calculate xy_cam_p1v.npy data
        c) save all information.
    4. Usage
        When using the data, load the xy_cam_p1v.npy & xy_pro_cv.npy
            grid_sample: xy_cam_cv.npy data
            (https://pytorch.org/docs/stable/nn.html?highlight=grid_sample#torch.nn.functional.grid_sample)
"""

import configparser
import sys
import os
import cv2
from matplotlib import pyplot as plt
import numpy as np
import DataProcess.util as dp
# from .util import load_bin_file, norm_from_depth, coord_visualization, process_epi_info, shade_from_norm, depth2xy


def main(main_path, data_set):

    main_path = main_path if main_path[-1] == '/' else main_path + '/'

    # Load config
    cfg = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())
    cfg.read(main_path + '000config.ini')

    # Some parameters (You should edit here every time):
    # main_path = '/media/qiao/Data/SLDataSet/Thing10K/1_3Views/test_3views'
    in_path = main_path + '1_3Views/%s_3views/' % data_set
    out_path = main_path + '2_DepthWithCorres/%s_corres/' % data_set
    # out_path = '/media/qiao/Data/SLDataSet/Thing10K/2_DepthWithCorres'
    # folder_name = '%s_corres' % data_set
    model_num = cfg.getint('DataInfo', '%s_model' % data_set)
    frame_num = cfg.getint('DataInfo', 'frame_num')
    cam_shape = (cfg.getint('Global', 'cam_height'), cfg.getint('Global', 'cam_width'))
    pro_shape = (cfg.getint('Global', 'pro_height'), cfg.getint('Global', 'pro_width'))

    calib_name = main_path + 'calib.ini'
    calib = configparser.ConfigParser()
    calib.read(calib_name)

    # rotation = [float(x) for x in config.get('Extrinsic', 'rotation').split(',')]
    # rot_mat = np.array(rotation).reshape(3, 3)
    # cam_intrinsic = np.array([[1201.35, 0.0, 640.0], [0.0, 1202.75, 512.0], [0.0, 0.0, 1.0]])
    # pro_intrinsic = np.array([[2274.82, 0.0, 640.0], [0.0, 2311.78, 400.0], [0.0, 0.0, 1.0]])
    # trans_vec = np.array([46.3635, -22.109, 113.778]).reshape(3, 1) * 1e-3
    # rot_mat = np.array([[0.998411, 0.0375734, -0.0419995],
    #                     [-0.0272844, 0.97441, 0.223118],
    #                     [0.049308, -0.221618, 0.973886]])
    # pro_vec = np.matmul(rot_mat.transpose(), np.array([[0.0], [0.0], [1.0]]))
    # pix_per_meter = 1200

    # Step 1: Calculate epipolar information here
    # M, D
    paras = dp.process_epi_info(cam_intrinsic=[float(x) for x in calib.get('Intrinsic', 'camera').split(',')],
                                pro_intrinsic=[float(x) for x in calib.get('Intrinsic', 'projector').split(',')],
                                rotation=[float(x) for x in calib.get('Extrinsic', 'rotation').split(',')],
                                transition=[float(x) for x in calib.get('Extrinsic', 'transition').split(',')],
                                cam_shape=cam_shape,
                                pro_shape=pro_shape,
                                scale=1e-3)
    par_mcp1, par_dcp1, par_mp1c, par_dp1c = paras

    # Step 2: Set dataset file_name list
    depth_cam_names = []
    depth_pro1_names = []
    # depth_pro2_names = []
    idx_set = []
    for m_idx in range(1, model_num + 1):
        for f_idx in range(0, frame_num):
            depth_cam_names.append('%s/%d/depth_cam_%d.bin' % (in_path, m_idx, f_idx))
            depth_pro1_names.append('%s/%d/depth_pro1_%d.bin' % (in_path, m_idx, f_idx))
            # depth_pro2_names.append('%s/%d/depth_pro2_%d.bin' % (main_path, m_idx, f_idx))
            idx_set.append((m_idx, f_idx))
    total_frame_num = len(depth_cam_names)

    # Step 3: Process every frame
    if not os.path.exists(out_path):
        os.mkdir(out_path)
    for idx in range(0, total_frame_num):
        depth_cam = dp.load_bin_file(depth_cam_names[idx], cam_shape)
        depth_pro1 = dp.load_bin_file(depth_pro1_names[idx], pro_shape)
        # depth_pro2 = load_bin_file(depth_pro2_names[idx], image_shape)

        # Set mask
        mask_cam = depth_cam < 9.0
        depth_cam[mask_cam == 0] = 0.0
        mask_pro1 = depth_pro1 < 9.0
        depth_pro1[mask_pro1 == 0] = 0.0
        # mask_pro2 = depth_pro2 < 9.0
        # depth_pro2[mask_pro2 == 0] = 0.0

        if idx_set[idx][0] > 0:
            # Calculate norm mat (-dz/dx, -dz/dy, 1)
            norm_cam, mask_cam = dp.norm_from_depth(depth_mat=depth_cam, mask_mat=mask_cam,
                                                    m_per_pix=calib.getfloat('Extrinsic', 'm_per_pix'))
            norm_pro1, mask_pro1 = dp.norm_from_depth(depth_mat=depth_pro1, mask_mat=mask_pro1,
                                                      m_per_pix=calib.getfloat('Extrinsic', 'm_per_pix'))

            # Calculate shape mat
            shade_cam = dp.shade_from_norm(norm_mat=norm_cam, mask_mat=mask_cam,
                                           rotation=[float(x) for x in calib.get('Extrinsic', 'rotation').split(',')])
            mask_cam[shade_cam.reshape(mask_cam.shape) <= 0] = 0
            shade_pro1 = dp.shade_from_norm(norm_mat=norm_pro1, mask_mat=mask_pro1,
                                            rotation=np.eye(3))
            mask_pro1[shade_pro1.reshape(mask_pro1.shape) <= 0] = 0

        # Calculate xy_pro1_cv
        xy_pro1_cv = dp.depth2xy(depth_mat=depth_cam, par_m=par_mcp1, par_d=par_dcp1, mask_mat=mask_cam)
        # xy_pro1_cv = np.zeros((cam_shape[0], cam_shape[1], 2))
        # tmp_mat_cv = par_mcp1[:, :, 2] * depth_cam + par_dcp1[2]
        # xy_pro1_cv[:, :, 0] = par_mcp1[:, :, 0] * depth_cam + par_dcp1[0]
        # xy_pro1_cv[:, :, 0] = xy_pro1_cv[:, :, 0] / tmp_mat_cv
        # xy_pro1_cv[:, :, 1] = par_mcp1[:, :, 1] * depth_cam + par_dcp1[1]
        # xy_pro1_cv[:, :, 1] = xy_pro1_cv[:, :, 1] / tmp_mat_cv
        # xy_pro1_cv[mask_cam == 0] = 0.0

        # Calculate xy_cam_p1v
        xy_cam_p1v = dp.depth2xy(depth_mat=depth_pro1, par_m=par_mp1c, par_d=par_dp1c, mask_mat=mask_pro1)
        # xy_cam_p1v = np.zeros((pro_shape[0], pro_shape[1], 2))
        # tmp_mat_p1v = par_mp1c[:, :, 2] * depth_pro1 + par_dp1c[2]
        # xy_cam_p1v[:, :, 0] = par_mp1c[:, :, 0] * depth_pro1 + par_dp1c[0]
        # xy_cam_p1v[:, :, 0] = xy_cam_p1v[:, :, 0] / tmp_mat_p1v
        # xy_cam_p1v[:, :, 1] = par_mp1c[:, :, 1] * depth_pro1 + par_dp1c[1]
        # xy_cam_p1v[:, :, 1] = xy_cam_p1v[:, :, 1] / tmp_mat_p1v
        # xy_cam_p1v[mask_pro1 == 0] = 0.0

        # Save
        prefix = 'm%02df%03d_' % (idx_set[idx][0], idx_set[idx][1])
        full_pre = out_path + prefix
        np.save(full_pre + 'depth_cam.npy', depth_cam.astype(np.float32))
        np.save(full_pre + 'depth_pro1.npy', depth_pro1.astype(np.float32))
        np.save(full_pre + 'xy_pro1_cv.npy', xy_pro1_cv.astype(np.float32))
        np.save(full_pre + 'xy_cam_p1v.npy', xy_cam_p1v.astype(np.float32))

        plt.imsave(full_pre + 'mask_cam.png', mask_cam, cmap='Greys_r')
        plt.imsave(full_pre + 'mask_pro1.png', mask_pro1, cmap='Greys_r')
        plt.imsave(full_pre + 'xy_pro1_cv.png', dp.coord_visualization(xy_pro1_cv, pro_shape), cmap='Greys_r')
        plt.imsave(full_pre + 'xy_cam_p1v.png', dp.coord_visualization(xy_cam_p1v, cam_shape), cmap='Greys_r')
        if idx_set[idx][0] > 0:
            plt.imsave(full_pre + 'shade_cam.png', shade_cam.reshape(cam_shape), cmap='Greys_r')
            plt.imsave(full_pre + 'shade_pro1.png', shade_pro1.reshape(pro_shape), cmap='Greys_r')
        print(full_pre + ' writing finished.')

    return


if __name__ == '__main__':
    assert len(sys.argv) >= 3

    main(main_path=sys.argv[1], data_set=sys.argv[2])
